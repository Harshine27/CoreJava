JAVA:
=====
programming language:
====================

English,Telugu,Hindi

communicate with machines
==========================

Machine language---------binary language/byte code-----------> 0's and 1's

applications:
=============

2 types:

 1.standalone /desktop applications:
 
   Eg: notepad,calculator etc

 2. distrubuted app/ network applications:
 
    Eg: Gmail, whatsp,facebook,instagram....

  2 types :
  =========

 1.pop(procedure oriented programming language)
 
  eg: c,cobol,b etc...

 2.oop(object oriented programming language)
 
   eg: java,python,c++,.net
   
   oop offers
   ==========   
   
   2 features:
   ===========
   
   1.performance
   
   2.security
   
  oops paradigm:
  =============
  4 concepts
  
  1.inheritance
  2.polymorphisam--------performance
  
  3.abstruction
  4.encapsulation--------------->> security
  
  
  java:
  =====
  java is a object oriented programming language
  
  which can be used develop both standlone and distrubuted applications.
  
  History of java:
  ================
  
  java was developed and realeased by--------->> sun micro systems
  
  in the year 1995
  
  oracle corporation
  
  who is the father of java??
  ===========================
  
  games gosling
  
  versions:
  ===========
  
  current version is:  java se 21
  ===================
  
  standard versions : java se 8,11 ,17 or 21
  ==================
  
  Long term support(LTS)
  ----------------------
  
  march and september....
  
  3 types of Editions:
  ======================
  
  1.Java Standard Edition(jse): standalone appl---- core java
  
  2.Java Enterprise Edition(jee): distrubuted-- advanced
  
  3.Java micro/mobile Edition(jme): mobile applications
  
  
  prerequisties of java program:
  
  ==============================
  1.we need to download software/ install the software
  
    jdk-----(java development kit)
	
	www.oracle.com
	
  2 we need editors
  
  notepad,notepadd++, Eclipse,netbeans,intellij
  
  3.write the code
  
  4.save the file(.java extension)
  
  5.compile the program
  
  6.Execute the program
  
  Structure of the java program:
  ==============================
  
  class <Classname>{
  
  public static void main(String[] args){
  
  // logic
  
  }
  
  
  }
  
  compile the program:
  ==================
  
  compiler
  
  converting high level language into Machine level language
  
           compiler
  source -------------->>byte code
  .java                  .class
  
  compilation
  ===========
  
  To compile:
  ===========
  javac Filename.java
  
  To Execute:
  ===========
  
  java Classname
  
  Why java??
  ==========
  
  1.platform independence:
  ==========================
  
       java is platform independent
	   
	    WORA----> write once run anywhere
		
		windows,linux,mac
		
		
		.windows ------------------------> Linux
		.class file                       .classfile
		
		
  2.Garbage collection:
  ========================
  
  500 variables(memory spaces)
  
  2 variables------498 are wasted
  
  Garbage collector-------unwanted memory space
  
  Garbage collection----------------increase performance
  
  
  Fundamentals of java:
  =====================
  
  class <ClassName>{
  
  public static void main(String args[]){
  
  // logic
  
  }
  
  
  keywords:
  =========
  we have 53 keywords
  
  }
  class: every java code need to be written inside the class
  
  main():
  
  ** compilation start from first line of the code and execution start from the main method
  
  jvm ----java virtual machine
  
  
  class : keyword which is used to dclare the class body
  
  main():  name of the method..
  
  public : keyword and acceess modifier
  
  static : keyword ----- class properties
  
  void : keyword --- it returns nothing
  
  String[] args: predefine class and used for data types
  
  args---> parameter for main method
  
  System.out.println: Sytem is a predefined class and out is a obj for a system and println is a mrthos
  
  working of java program:
  ==========================
                    compiler           jvm                       cpu
  java source code---------  byte code-------- Machine languge----------------output
                            .class file
  
  jdk,jre,jvm:
  ===========
  
  jdk:   java development kit
  
  jre: java runtime enviornment
  
  jvm : java virtual machine
  
  1.jdk:  development tools + [jre]
  ======
  deveopment tools   -----compiler and debugger
  jre
  
  2.jre 
  
  jvm and class libraries
  
  super set of jvm
  
  ** dont have any tools
  
  3.jvm(java virtual machine)
  
  jvm is resopnsible for cheching and executiong our java code
  
  
  
  langugage fundamentals:
  ========================
  1.mainmethod()
  
  2.data types
  
  3.keywords
  
  4.identifiers
  
  5.commandline arguments
  
  6.arrays
  
  https://www.javatpoint.com/javafx-how-to-install-java
  
  how we check java download or notepad
  
  ****** java -version
  
  (minuse)
                               
  keywords:
  ==========
  
  we have 53 keywords
  
  all the keywords need to be a lower case only....
  
  identifiers:
  ===========
  ** any name in java is said to be a identifier
  
  class name,variable name,method name
  
  Rules:
  ======
  a to z
  A to Z
  0 to 9
  
  **** 2 symbols are allowed
  
  1.$(doloor)
  
  2._(underscore)
  
  restrictions:
  ============
  1. no other symbols are allowd
  
  2. should not start with the digits
  
  3. keywords are not used allowed as a identifier..
  
  eg:
  Welcome
  
  class <Classname>{
         HelloWorld
  
  public static void main(String[] args){
  
  // logic
  
  }
  
  
  }
  
  ** classname
  ** main methd name
  ** String 
  ** args[]
  
  eg:
       name1-----> it is valid
	   1name------> it is not valid
	   
	   num = 10;
	   
	   Num = 20;// both difference
	   
  ** java strictly follows the case sensitive language
  
        num$ = 10; -----valid
		
		num# = 50;----------> not allowed (in valid)
		
		public = 50;---------->> invalid
		
		** keywords are not allowed to use as a identifier...
		
		name$ -------> valid
		
		_$_$_$ --------> valid
		
		15keys-----------> invalid
		
  naming conventions:
  =================
  ** clasname always starts with the uppercase letter
  
   Eg: Helloworld
   
    HelloWorld(proper identifier)
	
* all the variables and method name follows the camelCase

    Eg: nameOfStudent------camelCase----->> variablename
	
	    additionOfTwo()---------------->> method name
	  
	  **  keywords has to be a lower case
  
  
    Datatypes:
	=========
	Eg: 
	
	student
	===========
	1.nameof the student-----------divya
	2.address------------>hyd
	3.marks--------------numeric
	
	 name = divya;
	 
	 String name = "divya";
	 
	 ** representing the data type which ww want to store..
	 
	 2 types:
	 ==========
	 
	 1.primitive datatypes
	    2 types:
		=========
		1.numeric
		2.non numeric
	 
	 2.non primitive datatypes
	 
	    eg: String,arrays,clases
		
		integer:
		--------
		
		byte 
		short
		int 
		long-------------------->> numeric type of data
		
		float--------->   End with (f)
		double----------> we can store decimals values
		
		char----------> non numeric --- single character
		
		boolean----> non numeric------ true/false
		
		
		** 1 byte = 8 bits
		
		formula:
		=======
		
		****    -------------->>  -2^n-1 to (2^n-1)-1  ------------>>  -2^8 to -2^8-1(-128 to 127)
		
		n------>> no of bits
		
		
		Datatype              sizes             ranges                         default values
		
		
		byte                  1 byte           -128 to 127                           0
		
		short                 2 byte           -32768 to 32767                       0
		
		int                   4 bytes          -2147483648 to 2147483647             0
		
		long                  8 bytes          -9,223,372,036,854 to 9,223,..        0
		
		float                 4 bytes           6 to 7 decimals                      0.0
		
		double                8 bytes           15 decimals                          0.0
		
		char                  2 bytes           unicode( 0 to 65535)                 space
		
		boolean               1 bit                  na                            false
		
		
	variables:
	==========
	A varible is nothing but name of the memory location where our data get stored..
	
	int i = 10;
	
	Syntax:
	=======
	
	<datatype><varaiblename> = data/value;
	
	=  ---------->> assignment operator
	
	eg: int i = 10; 20
	
	    20 
		
		vary + able
		
	declartion:
	========
	syntax:
	======
	<datatype><variablname>;
	
	eg: int i;
	
	intilization:
	=============
	
	syntax:
	======
	
	<datatype><varaiblename> = data/value;
	
	Eg: int i = 50;
	
	int i ;
	
	2 types:
	========
	
	1.global variables
	
	2.local variables
	
	1.local variables:
	====================
	
	variables are defined inside a method
	
	
	2.global varaibles :
	===================
	
	varaibles  are defined inside a class but outside the main method
	
	** varaible ---properties
	
	class Test{
	
	// global varaiables
	
	public static void main(String args[]){
	
	// local variables
	
	}
	
	
	}
	
	
	global varaibles are 
	
	2 types:
	========
	
	1.static variables
	
	2.instance varaibles
	
	if it is static -----> static keyword before the variable it is static variable
	if it is no static --------> instance variable
	
	
	4 properties:
	=========
	1.syntax:
	===========
	
	static ------> we can use static
	instance ----> no static keyword
	
	2.memory:
	=========
	
	static : memory will get allocating only once at the time class loading into jvm...
	=======
	
	instance: memory will get allocationg for every object creation
	=========
	
	     obj?? 
		 
		 object is instance of class ------> memory allocation
		 
		 Syntax:
		 =======
		 
		 classname objref = new classname(); // obj creattion
		 
		 Test obj = new Test();
		 
		 Test obj2 = new Test();
		 
    3.how to access :
	================
   
   
   static properties:     can be accessed by using "class name"
   ===================
   
   instance properties:
   ================        can be accessed by using obj ref
   
   4.when to use :
   ===============
   static :  country, collegename , company name -----> common properties
   ==========
   
   instance : name , contact no-----------> unique properties
   =========
   
   
   Typecasting:
   ===========
   the process of converting one data type into another data type
   
   2 types :
   =======
   
   1.widening:
   ==========   
   
     smaller data type into larger data type
	 
   
      byte---short---char---int--long--float---double
   
   2.narrowing:
   ===============
   
   explicity we have to typecasting
   
   lossy conversion:
   ================
   
   here we loss some data..while we are coverting larger to smaller
   
   
   methods:
   =======
   
   
   method is a block of code which is defined to perform specific task
   
   eg:  int a = 10;
        int b = 20;
		
		int sum = a+b;
		
		syso(sum);
		
		** code reusablity
		
	 syntax:
     =============
    
     [access modifier]	<return type> <method name>(if paramerters) // method header /method signature
	 
	 {
	  // logic // method body
	 
	 }
	 
	 
	 eg:
	   
	   public static void main(String[] args){
	   
	   
	   
	   }
	   
	   ** methods get executed only when called..
		
		
	   ** methods addOfTwo()-----camelCase
	   
	   2 types:
	   ========
	   
	   1.predefined method
	   
	   2.user defined method
	   
	   main() , print(), length()
	   
	   2.user defined method:
	   ======================
	   
	   2 types :
	   ========
	   
	   1. static methods
	   2. instance metods...
	   
	   static method accessing by ----->>class name 
	   
	   instance methods accessing by using ----->> obj ref
	   
	   
	   packages:
	   ========
	   
	   packages are nothing but floders
	   
	   collection of class librariers
	   
	   package keyword
	   
	   import  keyword
	   
	   syntax:
	   ======
	   pacakge domain.company.package;
	   
	   2 types 
	   =======
	   
	   1.predefined package
	   
	   2.user defined package
	   
	   
	   **** java.lang is a default package
	   
	   ** Object class is a super class for all the java classes...
	   
	       11 methods.
		   
		pacakge com.corejava.basics;
		
		import package.*;
		
		import package.Classname;
		
		to compile : 
		==============
		
		javac -d . filename.java
		
		
		to execute :
		===========
		
		java packagename.filename
		
		
	 Dynamically inputs from the users:
	 ==================================
	 
	 run time inputs from the users
		
		
	   1.commandline arguments
	   
	   **2.Scanner class
	   
	   3.BufferdReader(file i/o)
	   
	   
	1.commandline arguments:
	========================
		
	public void display(String name){ // parameterized method
	
	Syso(name);
	
	
	}
	
	obj.display("divya");
	
	
	public static void main(String [] args){
	
	
	
	}
	
	array:
	
	int a = 1;
	
	int a = 1,2,3,4 ;
	
	array : we can stored multipule similar values 
	
	
	String name = "divya";
	
	String names[] = "divya","harshine","125", "25.2","true";
	
	
	Wrapper classes:
	================
	
	8 wrapper classes for 8 datatypes
	
	
	datatype                    wrapperclasses
	========================================
	byte                        Byte
	short                       Short
	int                         Integer
	long                        Long
	float                       Float
	double                      Double
	char                        Character
	boolean                     Boolean
	
	static methods:
	==============
	
	parseInt(), parseFloat(),.........
	
	
	array indexes
	
	index start from the -------->>0
	
	max index -------->> length - 1
	
	Scanner class:
	===============
	
	java.util.package
	
	https://docs.oracle.com/javase/8/docs/api/
	
	
	Scanner scan  = new Scanner(System.in);
	
	
	next(), nextInt(), nextFloat(),nextBoolean()
	
	Operators:
	==========
	
	1.Arthimetic Operator
	
	2.Assignment Operator
	
	3.Releational Operator
	
	4.Unary Operator
	
	5.Ternary operator
	
	6.Logcal Operator
	
	7.Bitwise Operator
	etc.....
	
	1.Arithemetic Operator:
	======================
	
	Eg : + , - , * , / , % 
	
	a + b ----->> addition operator
	
	
	2. Assignment operator:
	=======================
	
	 Eg : a = 5 ;
	        |
	        Assignment operator
			
			eg : a =  a + 5
			
			a += 5 ; // a = a+ 5; // 10
			
			compound operator :  -= , *= , /= , %=
			
	3. Relational operator :
    ========================
	
        > -----> greater than 
		
        < ----> less than
		
        >=-----> gretaer than or equal
		
        <= ---> lessthan or equal
		
        ==-------->> equal
		
        !=	-----> not equal
     
    4.Unary operator:
    ================
     	    
	     increment operator , decrement operator
		 
		 
		(++)----->  increment by 1
		
		   2 types :
		   ---------
		   
		   pre increment ----> prefix
		   
		   post increment-------> postfix
		
		(--) ----> decrement by 1
	
	2 types :
	----------
	
	1.pre decrement ---prefix
	
	2.post decrement -----> postfix
	
	eg: ++a-------> pre increment ---> by 1
	
        a++-----> 	 post increment --->> by 1
		
		 int a = 5 ;
		 
		 ++a   // 6
		 
		 a++  6 + 1 
		 
		 --a ----> 4
        a-- ----> 3	
		
		
	ternary operator :
	=================
	
	3 operands
	
	
     Syntax:
     ------	 
	 
	   condition ? exp1 : exp2;
	   
	   (a>b)  ? a : b;
	   
	   
	 Flow Controls:
	 ==============
	 
	 They describe the order in which statements will be executed
	 
	 3 types :
	 -------
	 
	 1.Selection stmts / Decision making stmts
	 
	 2.Loop stmts / Iterivate stmts
	 
	 3.Jump stmts / Transfer stmts
	 
	 
	 1. Decision making stmts :
	 =========================
	 
	  which statmt is executed and when to executed
	  
	   2 types :
	   -------
	   
	   1.If statement
	   
	   2.Switch statement
	   
	   
	   
	   
	   
	  1.if statements :
	  ================
	  
	  1.simple if :
	  ============
	  
	  syntax :
	  ---------
	  
	      if(condition){

            // stmts
		  
		  
		  }
		  
		  
	   2. if else statmt:
	   ==================
	   
	   syntax:
       -------	   
	   
	   
	   if(condition){
	   
	     // stmts1
	   
	   }
	   
	   else{
	   
	     // stmts2
	   
	   }
	   
	   3.if else if ladder:
	   ====================
	   
	   Syntax :
	   -------
	   
	   if(condition1){
	   
	      // stmt1
	   }
	   
	   else if(condition 2){
	   
	      // stmt 2
	   }
	   
	   else{
	   
	   // stmts3 
	   
	   }
	   
	   4.nested If :
	   ============
	   
	   Syntax : 
	   =======
	   eg : int a = 5 ;
	   
	   if(condition1){ // false (a >  0) 
	   
	       // stmts  --->  true
		   
	   if(condition2){ //(a== 0)
	       // stmt 2
	   
	   }
	   
	   else{
	   
	      // stmt 3
	   }
	   
	   }
	   
	   
	  2.switch statement:
	  ===================
	  
		syntax:
        =======
		
       switch(expression){
	   
	   case 1 :
	     // code
	   
	   case 2:
	   
	   // code
	   
	   default:
	     // code
	   
	   }		
		  
	  
	 
	 2.Iterative / loop statements:
	 ===============================
	 
	 boolean expresion
	 
	 3 types :
	 ========
	 
	 1.For loop
	 
	 2.While loop
	 
	 3.Do-While loop
	 
	 
	 1.For loop:
	 ===========
	 if no of iterations are known, we chose for loop
	 
	 
	 3 parts :
	 =========
	 
	 Syntax:
	 =======
	 
	 
	 for( intilization; condition, increment / decrement){
	 
	 // code
	 
	 
	 }
	 
	 2.While loop:
	 ============
	 
	 if we dont know num of iterations advance 
	 
	 Syntax:
	 ======
	 
	 while(condition){
	   // code 
	 
	    increment / decrement
	 
	 }
	 
	 
	   
	   3.Do- while loop:
	   ================
	   
	   if we dont know the num of iterations but if we want our code get execute atleast once
	   
	   
	   syntax:
	   =======
	   
	   do{
	    // code
	   
	   }while(condition);
	   
	   
	   
	   3.Transfer/ Jump stmts :
	   =======================
	   
	   
	   1.break ----------> Loops, switch statement
	      
		  when we give break statement ,it terminates the loop
	   
	   2. continue
	   
	      skip the current iteration and jump to the next iteration
	   
	   
	   
	   
	     JVM arichitecture:
		 ==================
	   
	   
	   
	     
		 
		      javac Filename.java     execution
		.java ----- . class file -------->> jvm------> output
	   
	       compilation
	   
	   
	     
		jdk----jre----jvm
		 
		jar files ----collection of .class files

        jar ---java archive		
	    
		Block:
		=====
		inside the braces we write some logic that particular code is nothing but Block
		
		{
		
		// code----------->> Block
		
		}
		
		static block------>> static{
		                         // code
		                         }
		
		instance block---------->{
		                        // code
		                        }
		
		
		literals:
		=========
		
		a constant value
		
		a constant value  which can be assigned to  a variable
		
		int x = 10;
		
		eg: 10, 23.2, false,"divya",'H';
		
		int x = 10L; 
		
		long l = 10L;
		
		String name = 'divya';
		
		
		Separtors:
		===========
		it is a symbol....which is used to defined a  struture of java program
		
		
		{}----> we write code inside this 
		
		[]-----> we declare array
		
		,.....(a , b )---passing the arguments
		
		;------->>  it terminates the statement
		
		. ------->  it devides the terms
		
		()---> method
		
		
		***********************************
		
		oops:
		=====---->> object oriented programming language
		
		oop is about creating object that contain both data members(variables) and member functions.(methods).
		
		oop pardiagm - 4
		====================
		
		1.Inheritance
		
		2.polymorphisam------->> performance
		
		3.abstruction
		
		4.encapsulation---------->>security
		
		
		key aspects:
		------------
		
		class and object
		
		class:
		=========
		
		a class is a blueprint for objects
		
		it is logical entity
		
		colection of datamebers nd member functions
		
		objects are created for class properties
		
		
		object:
		======
		
		object is instance of class // allocationg memory for class properties
		
		objects are created for memory allocation to class properties
		
		an objet is an entity which has both state and behaviour
		
		
		class student
		{               ------>100 students
		
		name 
		rollno
		age
		contact
		
		displayMarks(name , marks){
		 
		 
		 }
		 
		}
		
		std1 -------> divya
		               100
					   15
					   4565157--------> obj1
					   
	    std2 ------------> Harshine
		                    102
							12
							45242254-----> obj2
							
							
		1.Inheritance:
		==============
		 
		aacuring the properties from one class to another class 
		
		propetries can be variables, methods,constructors, interface 
		
		*****CODE RESUABILTY
		
		class A {
		
		// 100 methods
		
		+ 11 methods
		
		}
		
		public class  B extends A{
		
		// 50 methods
		
		+100 methods 
		=====         150 methods 
		+ 11 methods
		
		}
		
		
		2 keywords:
		============
		
		1.extends
		
		2.implements
		
		** Object class is super class for all java classes(11 methods)
		
		5 types:
		=========
		
		1.single  inheritance----> one parent---one child
		
		2.multilevel inheritance----SuperParent---Parent----Child
		
		3.hierarical inheritance---->> one parent and child1,child2
		
		4.multipule inheritance---->> many parents ---one child
		
		5.hybrid inheritance
		
		
		** mutipule inheritance is not supported at @class level in java
		
		
		we are having multipule classes in single java file but we have only one public class..
		
		
		** multipule inheritance is suppoerted at @interface Level
		
		
		abstract methods and concrete methods:
		=====================================
		
		concrete methods:
		================
		
		return type methodname(){
		
		// logic
		
		
		}
		
		public void display(){ // method signature
		
		// logic // method body
		
		
		}
		
		** method with implementation or method body
		
		
		abstract methods:
		=================
		
		** a method without implementation
		
		
		public abstract void display();-----> abstract method
		
		
		abstract keyword
		
		
		why???
		
		
		abstraction:
		===========
		
		hidding the unwanted information from users....
		
		security
		
		abstract classses and interface ...
		
		
		abstract class and interfaces:
		==============================
		
		concrete class: collection of only concrete methods
		
		
		abstract class:  collection of both concrete methods and abstract methods
		
		
		interface: collection of only abstract methods
		
		
		interface ** ----> keyword
		
		public abstract methods
		
		 public abstract void m1();
		
		** we are not creating the objects for abstract class and interface
		
		2 ways:
		=====================
		1.Abstract Class:(0-100 %)
		
		2.interfaces:(100 %)
		
	 Multipule inheritance:
     =====================
     many parents and one child	
	 
	 
	 class A{                                    class B{
	 
	                                             void m1(int a , int b){
	 void m1(int a , int b)										 
												  Syso( a*b)
	   Syso(a+b)
	 
	 }
	 
	                                             }
	 }
	                                             }
	 class C extends A,B{
	 
	 psvm(){
	 
	 C c = new C();
	 c.m1(10,5);
	 
	 }
	 
	 }
	 
	 possible @ interface level...
	 
	 polymorphism:
	 ============
	 poly---->many
	 
	 morphism -----forms
	 
	 having many form(different ways)
	 
	 
	 single task in different ways....
	 
	 
	 eg: humans--- as child, student,friends
	 
	 print method
	 
	 printString
	 
	 printInt
	 
	 printFloat
	 
	 2 types:
	 ===========
	 
	 1.compile time polymorphism
	 
	 2. run time polymorphism
	 
	 acheived in 2 ways:
	 
	 
	 1. Method Overloading--print method
	 
	 2.Method Overridding
	 
	 1.Method overloading:
	 =====================
	 method name is same,but signature different
	 
	   signature : 
	   
	   
	   no of parms
	   
	   order of parms
	   type of prms
	   
	   
	   print method
	   
	   Advantage of method overloading:
	   ================================
	   
	   code readablity
	 
	 
	 printString
	 
	 printInt
	 
	 printFloat---->> code readability
	 
	 print 
	 
	 
	 + ,  addition, concatenatation
	 
	 fnme + lastname =====>> divya+ Harshine--->> divyaHarshine
	 
	 (1 + 2)--->> 3
	 
	 add  2 3 
	 sum  5 6 7 
	 total 7 89 12 9 
	 
	 add  2 3 
	 add  5 6 7 
	 add  7 89 12 9 
	 
	 type promotion:
	 ==============
	 smaller data to larger data 
	 
	 method overriding:
	 =====================
	 method name is same , but implementation is different 
	 
	 ** parent class method will be overriden with child class 
	 
	 rules:
	 ======
	 
	 method name is same , implementation is diff
	 
	 
	 parent and child relations --------->>inherits 
	 
	 class Parent{
	 
	  int property(){
	      return 1000000000;
	   
	  }
	  
	  public void wedding(){
	  
	    Syso(" thamanna")
	  
	  }
	  
	 
	 }
	 
	 
	 class Child extends Parent{
	 
	 psvm(){
	 
	 Child c = new Child();
	 @Override
	 public void wedding(){
	  
	    Syso("Keerthi Suresh")
	  
	  }
	 
	 c.wedding();
	 
	 
	 
	 
	 }
	 
	 
	 
	 }
	 
	 Constructors:
	 ===========
	 
	 special method 
	 
	 it useed to intilize the object...
	 
	 eg:
    ====	 
	 
	   int a ; // declaration
	  
	   int a = 10; // intilozation
	   
	   syntax:
	   ======
	   
	   classname obj = new classname();
	   
	   classname obj = new constructor();
	   
	   ** whenever the obj is created a constructor get called implicity
	   
	   rules:
	   ======
	   
	   1. class name and constructor name both need to be same...
	   
	   
	   2. no return type
	   
	   
	   2 responsilbilites:
	   =======================
	   
	   1.to intilize the object
	   
	   2.to provide the default values to the instance properties...
	   
	   
	   2 types :
	   =========
	   
	   1.Default constructor------->> without parameters
	   
	   2.Paramererized consstructor-----> with parametrs
	   
	   
	   eg:
	   ====
	   
	   class Test{
	   
	   
	   void display(){ // normal method
	   
	   
	   }
	   
	   
	   Test(){ // default constructor 
	   
	   
	   }
	   
	   
	   class A{
	   
	    int b; // instance variables
		
		psvm(){
		
		A obj = new A();
		
		syso(obj.b);//  0
		
		}
	   
	   
	   
	   }
	   
	   
	   
	   }
	   
	   ** compiler will creates default constructor automatically...
	   
	   
	   class Test{
	   
	   Test(parametrs){ // paramertreized constructor
	   
	   
	   }
	   
	   
	   
	   }
	   
	   ** only one default constructor allowed....but we can take any parameterized constructors
	   
	   ** overloading is possiable
	   
	   final,this,super:
	   ==============
	   final:
	   ======
	   to restrict user..
	   
	   3 places:
	   ----------
	   
	   1. before variable
	   
	   2. before method
	   
	   3. before class 
	   
	 1.before variable:
	 =================
	   
	 once declared with final, values with in varaiable cannot be changesd
		
	2.before method:
	=================
	cannot change the implentation when we declared with final keyword(overriding is not poss)
	
	3.before class:
	==============
	
	we cannot extend the final class properties
	
	this $ super:
	============
	
	this:    refers to the current class properties
	=====
	
	super:    refers to parent class properties
	======
	
	
	properties can be variables,methods,constructors ,objects
	
	
	Access modifiers:
	=================
	
	4 modifiers:
	===============
	
	1.public 
	
	2.private
	
	3.protected
	
	4.default
	
	scope/ visiblity  of class, variables, methods, constructors also...
	 
	1. private: only within the class,cannot acceess outside the class.
	
	2. protected: anywhere within the pacakge whether it is child or not,but outside the package we can access
	              only when there is a parent child class relation(inheritance)
				  
	3.default: if we are not using any modifier,it behaves as default.
	          -->> only within the package,cannot access outside the package.
			  
	4.public: can be acceessed everywhere.
	
	used for :
	
	access modifier can be used for encapsulation
	
	**  miss use of data can be prevented
	
	Encapsulation:
	==============
	
	putting the things together
	
	wrapping up the data members and methods
	
	private --->> data members
	
	public methods ----->> getters , setters methods 
	
	data binding:   to make the data as private
	
	
	why encapsulation:
	------------------
	
	to better privacy....testing,debugging
	
	String  class:
	==============
																																																									
	Sequence /collection of characteers
	
	eg: "divya" 
	
	
	2. non- primiviate : String ,class, arrays
	===================
	
	** String is non-primitive data tpe
	
	** predefined class----------->> java.lang.package
	
	** String is a special class ------ representing the set of characters
	
	
	  String name = "Divya";
	  
	  All strings are object of a predefined class
	  
	  3 classes :   String 
	  =========
	  
	  1.String  --------> immutable
	  
	  scp --->> doest not allows duplicsaties --->> we dont want other memory reference to get changed
	  
	  2.StringBuffer------> muttable
	  
	  3.StringBulider-------->> muttable
	  
	  
	  java.lang.package
	  
	  
	  
	  String:
	  =======
	  
	  2 ways :
	  =======
	  
	  1.by using literal syntax
	  
	  2.by using new keyword
	  
	  
	  1.by using literal syntax:
	  ==========================
	  
	  
	  String name = "java";
	  
	  
	  classname obj = new classname();
	  
	  
	  2 : using new keyword:
	  =====================
	  
	  String name  = new String("java");
	  
	  
	  StringConstantPool:   (memory area )(SCP)
	  ===================
	  
	  
	  global:    instance,static
	  
	  local : 
	  
	  
	  heap area-----> instance 
	  
	  method area ----> static
	  
	  Stack area ---->> local
	  
	  
	  1. by using literal syntax:
	  =============================
	  
	  String name = "welcome";
	  
	  String name1 = "welcome";
	  
	  String name2 = "welcome";
	  
	  String is a special class it will get allocating the memory inside the scp(StringConstantPool)
	  
	  SCP does not allows the duplicate values 
	  
	  "==" operator------> memory references
	  
	  equals()-------> checks the values of strings
	  
	  
	  compareTo():
	  ============
	  
	  lexigraphically------>> alphabtecially
	  
	  1. returns 0 , if both objects are same 
	  
	  2. returns negative, if obj1 comes before obj2
	  
	  3.returns positive , if obj1 comes aftr obj2 
	  
	  StringBuffer and StringBulider:
	  ===============================
	  
	  StringBuffer sb = new StringBuffer("java");
	  
	  String ----equals()------>> values
	  
	  StringBuffer and StringBulider---> equals()---> memory reference
	  
	  StringBuffer ---->> Synchronized
	  
	  StringBulider ---->> non Synchronized 
	  
	  synchronized:
	  =============
	  
	  t1,t2,t3----->> keyword
	  
	  ----->> thread safety 
	  
	  
	  StringBuffer ------->> synchronized ---->> thread safety
	  
	  StringBulider --->> non synchronized ---->> better performance
	  
	 https://www.w3schools.com/java/java_ref_string.asp 
	  
	  
	  Arrays:
	  ======
	  it is an indexed collection of fixed no of homogenous data elements
	  
	  ** array is an object
	  
	  String name = "Harshine" ,"Divya","Prashanti";
	  
	  10 students 
	  
	  name1 = divya 
	  name2 = harshine
	  
	  String[] name = {"harshine", "divya", "prashanti"}; // by using literal way to create array obj
	  
	  int[] num = {1,2,3,4,5,6};
	  
	  2 ways;
	  ======
	  2.String[] name = new String[2]; // by using new keyword
	  
	  advantages:
	  ============
	  
	  >> group of elements / data together
	  
	  >> code readbility
	  
	  disadvantages:
	  ===============
	  
	  1.stores only similar data
	  
	  2.an array is fixed in size
	  
	  note:
	  ==========
	  
	  **array object will get memory allocation inside the heap area
	  
	  arrays can be accessed with the help of index values
	  
	  
	  2 types of arrays:
	  ==================
	  
	  1.single dimensional array
	  
	  2.multi dimensional array
	  
	  1 2 3
	  4 5 6 
	  7 8 9 
	  
	  Exception Handling:
	  ===================
	  
	  converting the system defined  error messages into user friendly error messages.
	  
	  
	  limitations:
	  ==========
	  
	  1.system defined error message 
	  
	  2.abnormally terminated
	  
	  exception handling;
	  ===================
	  
	  1.try
	  
	  2.catch
	  
	  3.finally
	  
	  4.throw
	  
	  5.throws
	  
	  errors:
	  =======
	  
	  2 types:
	  --------
	  
	  1.compiletime errors:(poor understanding of the language)
	  -----------------------
	  
	  2.runtime errors: invalid inputs
	  --------------------
	  
	  **exception is nothing but object 
	  
	  Exception:
	  ----------
	  exception is an unexpected event that distrupts the normal flow of program.
	  
	  types of exceptions:
	  ===================
	  
	  3 types:
	  =======
	  
	  1 checked exceptions-------> at compiletime
	  
	  2.unchecked------->> at runtime
	  
	  3.errors
	  
	  
	  try: always we have to place risky code inside the try block
	  -----
	  
	  catch: catch will handle the exception and it will give the some user friendly error message.
	  -------
	  
	  finally: it always executes eventhough the exception is raised or not,,,,
            	  always executes the finally block code.(closing connections)
	  -------
	  throw:   raise an exception explicity  
	  ======
	  throws:  declared the exceptions
	  ======
	  
	** Throwable class is super class for all the exception classes..    Exception clas inherits Throwable 
	  
	  
	 system defined
	 
     user defined	
     
     user defined expection:
     =======================
	 
      	 1. take class ------>> child class--->> we have extends Exception class 
		 
		 2.take one paramerterized constructor and toString()
		 
	     File Handling:
	     =============
	     Predefined class ---->. java.io.package
	
	     create, write,read
	  
	   predefined classes to write into file:
	   ======================================
	  
	     1.FileWriter
		 
	     2.BufferedWriter
		 
	     3.PrintWriter
	  
	  
	  predefined classses to read the data from file:
	  ==============================================
	  
	  1.FileReader
	  
	  2.BufferdReader
	
	File class:
	==========
	
	predefined class ---->> java.io.package
	
	File f = new File("hello.txt");
	
	FileWriter:
	==========
	
	write()----->> write the data into our file
	
	limitations:
	===========
	
	--->> no number data allowed
	
	----->> Everytime we have to use "\n"
	
	BufferdWriter:
	==============
	
	write()
	
	no number data allowed
	
	Every time we have to use newLine()
	
	PrintWriter:
	============
	
	println()
	
	FileReader:
	==========
	
	read()-----> it returns int type
	
	limitations:
	===========
	
	read the data character  by character
	
	BufferedReader:
	==============
	
	readLine()--------->> it returns String type
	
	read the data Line by line
	
	Serialization and De-Seraiaization:
	====================================
	Serialization:
	==============
	
	converting the obj data into byte data
	
	
	De-Serialization:
	================
	
	converting the byte data into obj data
	
	to seriazlizable:
	================
	
	2 classes:
	
	1.FileOutputStream
	
	2.ObjectOutputStream---------->writeObject()
	
	to DE-seriazlizable:
	================
	
	2 classes:
	
	1.FileInputStream
	
	2.ObjectInputStream---------->readObject()
	
	** Serializable ---marker interface ----no abstract methods (zero interface  )
	
	Multi Threading:
	================
	
	multi tasking:
	==============
	Executing several tasks at a time
	
	2 types:
	----------
	
	1.process based multitasking
	
	2.Thread based multitasking
	
	process:
	=======
	
	collection of threads
	
	
	1.process based multitasking:
	==============================
	
	Executing several tasks at time but each task is seperate independent process
	
	
	EG: Laptop (Eclipse,Notepad,google,teamslink)
	
	
	2.Thread based multitasking:
	=============================
	
	Thread is smallest unit of process 
	
	Executing several tasks at time but each task is releated same process
	
	suppose
	
	Eg: notepad(typing,sugesstions)
	
	
	Eg: Eclipse(Typing code,compiling,Exceuting,suggestions)
	
	
	Threads will contain the within process 
	
	
	Advantages of multithreading:
	============================
	
	class Test{
	
	1.connecting file
	2.reading from file------5 hurs------> Thread1
	
	
	
	1000 lines of code-------->> Thread2
	
	}
	
	why??
	-------
	
	to improve response time for better performance
	
	2 ways:
	========
	
	1.by implementing Runnable interface
	
	2.by extending the Thread class
	
	Runnable interface:
	===================
	Runnable interface said to be Funtional interface 
	
	javap java.io.Serializable
	Compiled from "Serializable.java"
    public interface java.io.Serializable {
    }

    ------->> SAM(single abstract method)
  
  
     class Test implements Runnable{
	 
      run(){
      // code for which thread need to be create
  
     }
  
  
     }
	
	
	 ** Thread class is child class for Runnable interface
	
	   start()----->> run()
	
	
	Thread priorities:
	==================
	
	ranges: 1-10
	
	1---min thread prority
	
	10--max thread priority
	
	5- normal(default) priority
	
	** main thread priority is 5
	
	** currentThread()----->> static -----by class name-----> it returns current thread object
	
	
	Thread life cycle:
	==================
	https://www.javamadesoeasy.com/2015/03/thread-states-thread-life-cycle-in-java.html
	
	5 states:
	
	1.New ---> when the thread class obj is created thread will be in the new state
	
	2.Runnable---> when start() call thread will be in the Runnable stat
	
	3.Running----> start() call run method  when the current Thread is executing by run method Thread will be in running
	
	4.Terminated(Dead state)--->> when Thread logic is completed Thread will be in the Terminated state
	
	5.waiting/sleeping state--->> Thread Executing time we call any method sleep() ,wait()Thread will go to waiting state
	
	
	sleep(5000)----->> 1000 nano sec---> 1 sec
	
	
	sleep(),join(),yiled(),Synchronization
	
	
	yiled():--->>priority
	=======
	
	t1----6------yiled()-----pause------>> stop
	t2----7
	t3----8------>> 
	
	
	join():
	-------
	if want specific thread we call join method until the completion of Execution of that thread remaining Threads not executed.
	
	Synchronization:
	================
	Eg:
	---
	t1
	t2
	t3
	
	until the completion of first Thread remaning Threads has to be wait
	
	
	Collections Framework:
	======================
	
	Readymade arichitecture
	
	
	collections is a framework
	
	Arrays:
	-----
	we can store group of objects 
	
	limitations:  3
	
	===========
	
	1. we can store only homogenous / similar data/objects
	
	2. arrays are fixed in size
	
	3. no utilty methods
	
	variable: single value
	
	
	collections Advantages:
	=======================
	
	1.both homogenous/ hetrogenous data can be stored
	
	2.collections are not fixed in size nothing growable in nature
	
	3.utility methods 
	
	
	eg:
	
	int a[] = {12,2,2.3f,'a'}; // hetrogenous / dissimilar
	
	int a[] = {1,2,3,4,5}; // homogenous/ similar
	
	
	collection classes java.util.package
	
	collections:
	==========
	Eg: cover is a container
	
	collection is a interface Which is super class for all collection classes
	
	
	Comparable and Comparator:
	=========================
	
	Comparable is present in -----------> java.lang package
	
	compareTo()------ natural sorting order
	
	Comparator  -----------------------> java.util package
	
	compare() -----> Custom Sorting Order
	
	eg: -bat.compareTo(cat);     
	     cat
		 
	     -(-1) ----->>>  +1
		 
		 ReverseOrder:
		 ============
		 
		 1.change the objects
		 
		 2.place negative sign before a object
	
	     MAP:
		 ====
		 key and value pair
		 
	
	     ***** CASE STDUY:   corejava--------------->> Banking Operations
		       ===========
	
	
	    Layered Arichiteture:
		=====================
	
	    Static imports:
		==============
		
		import packagename.classname.*;
		
		 import java.lang package.System;
		 
		 Scanner:
		 
		 import static  java.util.Scanner; // ctrl+ shift + o
	      
		 syntax for static imports:
		 ==========================
		 
	     import static pacakagename.*;
	
	    
		Enum:
		=====
		enum------>> instead of class,interface we can use this keyword
		
		---UPPERCASE   
		
		Eg: SUNDAY,
		
		
		java5 feauters:
		================
		
		
		autoBoxing / unBoxing
		
		primitive data types:             Wrapper classes:
		
		====================             =================
		int                                 Integer
		
		short                         		Short
		
		byte                                 Byte
		
		char                                Character
		
		boolean                             Boolean
		
		float                                Flaot
		
		etc....
		
		autoBoxing:  converting primitivte data type into wrapper class object.
		-----------
		
		unboxing:    converting wrapper class object into  primitive data type.
		---------
		
		
		
		java6 :
		
		collection Frame works,jar file
		
		
		java7:
		
		switch, Exception Handling,catch 
		
		
		java 8 features:
		================
		
		when??
		
		2014, march 18 th
		
		
		python: ------------->>Functional programming  
		=======
		
		10 lines of code
		
		
		comming to java:
		================
		
		100 lines of code
		
		some features:
		=============
		
		
		1.Lamda Expression
		
	    2.Functional Interface(SAM)
		
		3.static,default, methods in interrface
		
		4. Functional Interfaces(SAM)
		
		   predicate
		   
		   functions
		   
		   Consumer
		   
		   Supplier
		   
		5.DATE and TIME API
		
		6.Streams
		
		1.Lamda Expression:
		===================
		
		Annoymous Function
		
		      *Nameless
			  
			  *no need of return type
			  
			  *no need of accesss modifier
			  
		Functional programming:
        ===============================	

        procedure   oop	(objects)	
			  
		Function---Methods	
		
		Objectives of java 8:
		======================
		
		    1.simpilfied code(concised code)
			
			2.to introduce functional programming
			
			3.to enable parallel programming
			
			
			Eg:  Normal method
			
			    public void m1(){
				
				System.out.println("HelloWorld");
				
				} // normal method
				
				Lamda:
				======
				
				  ()->System.out.println("HelloWorld");
				
				  lamda symbol (->)
				
				
				Eg 2:
				=====
				
				public void addition(int a , int b){
				
				Syso(a+b);
				
				}
				
				Lamda :
				======
				
				  ( a , b )->Syso(a+b);
				
				
				** there is no lamda expression without functional interface
				
				** compiler will guess the type of paramaters no need to give explicity
				
				
		     2.Functional Interface:  (SAM)
			 
			 =======================
			 
			 Annotation @Functional Interface ---->> it s optional 
			 
			 
			 
			 3. Default and static methods in intefaces:
			 ===========================================
			 
			 from java 1.8 version default and static methods wil be used in the INTERFACE
			 
			 
			 Default methods in interface:
			 =============================
			 
			 public abstract 
			 
			 interface I{
			 
			   void m1();
			   
			   default void m2(){
			   
			      Syso("DEfult method);
			   
			   }
			 
			 }
			 class One  implements I{
			 
			 void m1(){
			 
			 Syso("HELLO");
			 
			 }
			 void m2(){
			 
			 Syso("HELLOooooooooooooo");
			 
			 }
			 
			 class Two  implements I{
			 
			 void m1(){
			 
			 Syso("HELLO");
			 
			 }
			 
			 
			 class Three implements I{
			 
			 @Override
			 public void m2(){
			 
			 Syso("HELLO");
			 
			 }
			 }
			 
			 }
			 }
			 
			 static methods in the interface :
			 =================================
			 
			 
			 class                        interface          
			 
			 
			 implementation methods       abstarct methods  
			 
			 obj creation
			 
			 data can be
			 
			 costly                             cheap
			 
			 heavier                               lighter
			 
			 
			 by using class name (we dont create any obj for statc mtds)
			 
			 
			 static methods @ interface ----from java 1.8
			
             better performanace 

		
			  
			5.Date and Time API:
			====================

            classes and interface	

            LocalTime  hr-ms-sec

            LocalDate  yr-mm-dd

            LocalDateTime			
			  
			  
			streams:
            ========
            
        Collection and stream : 
		=====================
		Collection: if we want to store group of objects into a single entity 


        Stream :   if we want to process of obj from collection	
		
		
		java.util.stream package
		
		Stream s = c.stream();
		
		filter
		map
		sorted
		count
		
		
		DATA BASE:
		==========
		DATA:
		=====
		Collection of information from any source
		
		DATA BASE:
		==========
		used to store and oraganize our data for fucture purpose and security...
		
		DBMS:
		=====
		Data base management system..
		
		
		software tool
		
		
		RDBMS:
		======
		realational database mnagement sysytem
		
		realation:  -------->> Tables 
		
		Table : rows and columns
		
		rows ----->> records
		
		coulmns--->> fileds
		
		RDBMS
		
		Mysql: (DBMS)
		======
		
		SQL: (Structured query language)
		
		
		Queires
		
		5 types of queires:
		====================
		
		1.DDL(Data Definition Language):--
		
		   Commands  --------->>create,alter,truncate,drop,rename
		
		2.DML(Data Manipulation Language):-
		
		    Commands : insert,update,delete,merge
		
		
		3.DQL /DRL(Data Query Lang/ data Retrivel)
		
		    Command : select
		
		4.DCl (Data Control Language):-
		
		  Commands :  grant,revokke
		
		5.TCL(Transaction Control Language )
		
		Commands :  commit,savepoint,rollback
		
		
		CRUD operations:
		================
		
		create,read,update,delete
		
		
		constraints:
		    primary key
			unique
			foriegn key
			not null 
			check
		
		joins:
		
		  inner join
		  
		  left join
		  
		  right join
		  
		 
		
		JDBC:
		=====
		Java Database Connectivity
		
		API---Application programming interface
		
		4 Drivers:
		
		1.JDBC-ODBC bridge driver
		
		2.Native API driver
		
		3.Network protocal driver
		
		4.Thin driver
		
		
		steps to follow to connect :
		==========================
		
		5 steps:
		--------
		
		
		1.Loading the Driver classs 
		
		2.Create the Connection
		
		3.Create the Statement
		
		4.execute the Queires
		
		5.close the Connection
		
		JPA:
		=====
		
		disadvantages of jdbc:
		=====================
		
		1.Biloerpalte code
		
		2.Exception handling
		
		3.switching among the databases
		
		4.writing queires
		
		JPA:
		====
		
		Java persistence API
		
		JPA --Interface
		
		Hibernate ---> implementation 
		
		Jpa is a specification given by sun micro systems..
		
		
		crud operations:
		================
		
		create,read,update,delete
		
		
		create/insert ------>> persist()
		
		
		read/select  -------->> find()
		
		
		update ------------>>>  merge()
		
		
		delete --------------->> remove()
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		

		

     		
		
		   
		   
		
		     
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		